const t=JSON.parse('{"key":"v-b0d5b6fa","path":"/Notebook/Rust/%E6%89%80%E6%9C%89%E6%9D%83.html","title":"所有权","lang":"zh-CN","frontmatter":{"title":"所有权","category":["笔记","Rust"],"description":"栈内存(Stack) &amp; 堆内存(Heap) Stack 按值的接受顺序来储存,按相反的顺序将它们移除(后进先出 LIFO,LastIn FirstOut) 添加数据叫做压入栈(压栈) 移除数据叫做弹出栈(出栈) 所有储存在 Stack 上的出局必须拥有固定一致的大小 编译时大小未知的数据或运行时大小可能发生改变的数据必须存放在 Heap 上 Heap 内存组织性差一些 当数据放入 Heap 时,程序将请求一定数量的空间 操作系统在 Heap 里找到一块足够大的空间,把它标记为在用,并返回一个指针,也就是这个内存的空间地址 这个过程叫做在 Heap 上进行分配,有时仅仅称之为分配 存储数据 把值压到 Stack 上不叫分配 指针是已知固定大小,可以把指针存放在 Stack 上 But,如果想访问实际数据,则必须使用指针进行定位 把数据放到 Stack 上比放在 Heap 上要快得多,因为操作系统不需要寻找用来储存数据的空间,那个位置永远在 Stack 的顶端 访问数据 访问 Heap 中的数据要比访问 Stack 中的数据慢,因为需要用过指针才能找到 heap 中的数据。对于现代的处理器来说,指令在内存跳转的次数越少,,熟读就越快 如果数据放的距离比较近,那么处理速度就会快一些(Stack 上) 如果数据放的距离比较远,那么处理速度就会慢一些(Heap 上) 函数调用: 当你的代码调用函数时,值被传入函数(也包括指向 heap 的指针). 函数本地的变量被压到 Stack 上. 当函数结束后,这些值会从 Stack 上弹出","head":[["meta",{"property":"og:url","content":"https://skyixx.github.io/Notebook/Rust/%E6%89%80%E6%9C%89%E6%9D%83.html"}],["meta",{"property":"og:site_name","content":"ColorSky"}],["meta",{"property":"og:title","content":"所有权"}],["meta",{"property":"og:description","content":"栈内存(Stack) &amp; 堆内存(Heap) Stack 按值的接受顺序来储存,按相反的顺序将它们移除(后进先出 LIFO,LastIn FirstOut) 添加数据叫做压入栈(压栈) 移除数据叫做弹出栈(出栈) 所有储存在 Stack 上的出局必须拥有固定一致的大小 编译时大小未知的数据或运行时大小可能发生改变的数据必须存放在 Heap 上 Heap 内存组织性差一些 当数据放入 Heap 时,程序将请求一定数量的空间 操作系统在 Heap 里找到一块足够大的空间,把它标记为在用,并返回一个指针,也就是这个内存的空间地址 这个过程叫做在 Heap 上进行分配,有时仅仅称之为分配 存储数据 把值压到 Stack 上不叫分配 指针是已知固定大小,可以把指针存放在 Stack 上 But,如果想访问实际数据,则必须使用指针进行定位 把数据放到 Stack 上比放在 Heap 上要快得多,因为操作系统不需要寻找用来储存数据的空间,那个位置永远在 Stack 的顶端 访问数据 访问 Heap 中的数据要比访问 Stack 中的数据慢,因为需要用过指针才能找到 heap 中的数据。对于现代的处理器来说,指令在内存跳转的次数越少,,熟读就越快 如果数据放的距离比较近,那么处理速度就会快一些(Stack 上) 如果数据放的距离比较远,那么处理速度就会慢一些(Heap 上) 函数调用: 当你的代码调用函数时,值被传入函数(也包括指向 heap 的指针). 函数本地的变量被压到 Stack 上. 当函数结束后,这些值会从 Stack 上弹出"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-29T06:38:08.000Z"}],["meta",{"property":"article:author","content":"ColorSky"}],["meta",{"property":"article:modified_time","content":"2023-08-29T06:38:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"所有权\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-29T06:38:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ColorSky\\",\\"url\\":\\"https://ColorSky.fun\\"}]}"]]},"headers":[{"level":2,"title":"所有权规则","slug":"所有权规则","link":"#所有权规则","children":[{"level":3,"title":"变量作用域","slug":"变量作用域","link":"#变量作用域","children":[]}]},{"level":2,"title":"内存分配","slug":"内存分配","link":"#内存分配","children":[]},{"level":2,"title":"变量数据交互的方式","slug":"变量数据交互的方式","link":"#变量数据交互的方式","children":[]}],"git":{"createdTime":1691998057000,"updatedTime":1693291088000,"contributors":[{"name":"skyixx","email":"ningstars@outlook.com","commits":5}]},"readingTime":{"minutes":2.77,"words":830},"filePathRelative":"Notebook/Rust/所有权.md","localizedDate":"2023年8月14日","excerpt":"<h1> 栈内存(Stack) &amp; 堆内存(Heap)</h1>\\n<ul>\\n<li>\\n<p>Stack 按值的接受顺序来储存,按相反的顺序将它们移除(后进先出 LIFO,LastIn FirstOut)</p>\\n<ul>\\n<li>添加数据叫做压入栈(压栈)</li>\\n<li>移除数据叫做弹出栈(出栈)</li>\\n</ul>\\n</li>\\n<li>\\n<p>所有储存在 Stack 上的出局必须拥有固定一致的大小</p>\\n<ul>\\n<li>编译时大小未知的数据或运行时大小可能发生改变的数据必须存放在 Heap 上</li>\\n</ul>\\n</li>\\n<li>\\n<p>Heap 内存组织性差一些</p>\\n<ul>\\n<li>当数据放入 Heap 时,程序将请求一定数量的空间</li>\\n<li>操作系统在 Heap 里找到一块足够大的空间,把它标记为<code>在用</code>,并返回一个指针,也就是这个内存的空间地址</li>\\n<li>这个过程叫做在 Heap 上进行分配,有时仅仅称之为<code>分配</code></li>\\n</ul>\\n</li>\\n<li>\\n<p>存储数据</p>\\n<ul>\\n<li>把值压到 Stack 上不叫分配</li>\\n<li>指针是已知固定大小,可以把指针存放在 Stack 上\\n<ul>\\n<li>But,如果想访问实际数据,则必须使用指针进行定位</li>\\n</ul>\\n</li>\\n<li>把数据放到 Stack 上比放在 Heap 上要快得多,因为操作系统不需要寻找用来储存数据的空间,那个位置永远在 Stack 的顶端</li>\\n</ul>\\n</li>\\n<li>\\n<p>访问数据</p>\\n<ul>\\n<li>访问 Heap 中的数据要比访问 Stack 中的数据慢,因为需要用过指针才能找到 heap 中的数据。对于现代的处理器来说,指令在内存跳转的次数越少,,熟读就越快</li>\\n<li>如果数据放的距离比较近,那么处理速度就会快一些(Stack 上)</li>\\n<li>如果数据放的距离比较远,那么处理速度就会慢一些(Heap 上)</li>\\n</ul>\\n</li>\\n<li>\\n<p>函数调用: 当你的代码调用函数时,值被传入函数(也包括指向 heap 的指针). 函数本地的变量被压到 Stack 上. 当函数结束后,这些值会从 Stack 上弹出</p>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
